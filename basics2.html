<p>Esta lección cubre los siguientes temas:</p>
<ul>
	<li><a href="#apply">El método apply</a></li>
	<li><a href="#object">Objetos</a></li>
	<li><a href="#fnobj">Las funciones son objectos</a></li>
	<li><a href="#package">Paquetes</a></li>
	<li><a href="#match" title="Pattern Matching">Coincidencia de patrones</a></li>
	<li><a href="#caseclass">Clases caso</a></li>
	<li><a href="#exception">Try-catch-finally</a></li>
</ul>
<h2 id="apply">El método apply</h2>
<p>El método <code>apply</code> puede agregar una agradable azúcar sintáctica para cuando una clase u objeto tiene un uso principal.</p>
<pre>
scala&gt; class Foo {}
defined class Foo

scala&gt; object FooMaker {
     |   def apply() = new Foo
     | }
defined module FooMaker

scala&gt; val newFoo = FooMaker()
newFoo: Foo = Foo@5b83f762
</pre>
<p>o</p>
<pre>
scala&gt; class Bar {
     |   def apply() = 0
     | }
defined class Bar

scala&gt; val bar = new Bar
bar: Bar = Bar@47711479

scala&gt; bar()
res8: Int = 0
</pre>
<p>Aquí, en nuestro objecto de instancia, parece que estamos llamando a un metodo. Veremos más sobre esto más adelante!</p>
<h2 id="object">Objectos</h2>
<p>Los objetos solterones (singleton <code>object</code>)  se utilizan para mantener una sola instancia de una clase. A menudo se utilizan como fabricas de objetos.</p>
<pre>
object Timer {
  var count = 0

  def currentCount(): Long = {
    count += 1
    count
  }
}
</pre>
<p>Como se usa:</p>
<pre>
scala&gt; Timer.currentCount()
res0: Long = 1
</pre>
<p>Las Clases y los Objetos pueden tener el mismo nombre. El <code>object</code> es normalmente llamado &#8220;objeto acompañante&#8221;. Utilizamos comúnmente los objetos acompañantes para las fabricas de objetos.</p>
<p>Aquí está un ejemplo trivial que sólo sirve para eliminar la necesidad de utilizar &#8220;nuevo&#8221; para crear una instancia.</p>
<pre>
class Bar(foo: String)

object Bar {
  def apply(foo: String) = new Bar(foo)
}
</pre>
<h2 id="fnobj">Las funciones son objetos</h2>
<p>En Scala, hablamos de programación objeto-funcional a menudo. ¿Qué significa eso? ¿Qué es una función realmente?</p>
<p>Una función también puede ser vista conjunto de rasgos. Siendo más específicos, podemos crear una función que toma un argumento y que es una instancia de un rasgo  de <code>Function1</code>, como se ve en el ejemplo. Este rasgo define el método <code>apply()</code>  que agrega azúcar sintáctica y  que permite llamar a un objeto como si fuera una función.</p>
<pre>
scala&gt; object addOne extends Function1[Int, Int] {
        def apply(m: Int): Int = m + 1
      }
defined module addOne

scala&gt; addOne(1)
res2: Int = 2
</pre>
<p>Hay <a href="http://www.scala-lang.org/api/current/index.html#scala.Function0"> Function0</a> a 22. ¿Por qué 22? Es un número mágico arbitrario. Yo nunca he necesitado una función con más de 22 argumentos por lo que parece funcionar.</p>
<p>El azúcar sintáctica de <code>apply</code> ayuda a unificar la dualidad de la programación orientada a  objetos y la programación funcional. Es decir, puedes pasar clases y usarlas como funciones,  mientras que las funciones son sólo instancias de clases tras bambalinas.</p>
<p>¿Esto significa que cada vez que se define un método en su clase, usted está consiguiendo realmente una instancia de <code>Function</code>* ? No, los métodos de las clases son métodos. Los métodos definidos independiente en el repl son instancias de <code>Function</code>* .</p>
<p>Las clases también pueden ampliar <code>Function</code> y las instancias pueden ser llamadas con ().</p>
<pre>
scala&gt; class AddOne extends Function1[Int, Int] {
        def apply(m: Int): Int = m + 1
      }
defined class AddOne

scala&gt; val plusOne = new AddOne()
plusOne: AddOne = &lt;function1&gt;

scala&gt; plusOne(1)
res0: Int = 2
</pre>
<p>Un buen atajo para  <code>extends Function1[Int, Int]</code> es <code>extends (Int =&gt; Int)</code>.</p>
<pre>
class AddOne extends (Int =&gt; Int) {
  def apply(m: Int): Int = m + 1
}
</pre>
<h2 id="package">Paquetes</h2>
<p>Puedes organizar tu código dentro de paquetes, como se observa a continuación:</p>
<pre>
package com.twitter.example
</pre>
<p>En la parte superior de un archivo se declarará  que todo lo que esté en el archivo va a estar en el paquete.</p>
<p>Los valores y las funciones no pueden estar fuera de una clase u objeto. Los objetos son una herramienta útil para la organización de funciones estáticas.</p>
<pre>
package com.twitter.example

object colorHolder {
  val BLUE = "Blue"
  val RED = "Red"
}
</pre>
<p>Entonces, ahora se puedes acceder a los miembros directamente:</p>
<pre>
println("the color is: " + com.twitter.example.colorHolder.BLUE)
</pre>
<p>Note lo que el repl scala dice al definir este objeto:</p>
<pre>
scala&gt; object colorHolder {
        val Blue = "Blue"
        val Red = "Red"
      }
defined module colorHolder
</pre>
<p>Esto nos da una pequeña pista de que los diseñadores de Scala diseñaron los objetos solterones (<code>object</code>) para ser parte del sistema de módulos de Scala.</p>
<h2 id="match">Coincidencia de patrones (Pattern Matching)</h2>
<p>Esta es una de las partes más útiles de la Scala.</p>
<p>Coincidencia en valores:</p>
<pre>
val times = 1

times match {
  case 1 =&gt; "one"
  case 2 =&gt; "two"
  case _ =&gt; "some other number"
}
</pre>
<p>Coincidencia con guardias:</p>
<pre>
times match {
  case i if i == 1 =&gt; "one"
  case i if i == 2 =&gt; "two"
  case _ =&gt; "some other number"
}
</pre>
<p>Observe cómo capturamos el valor en la variable &#8220;i&#8221;.</p>
<p>El <code>_</code> en la última declaración de caso es un comodín (wildcard), que asegura que podemos manejar cualquier declaración o caso. De lo contrario, podríamos sufrir un error de ejecución si pasas un número que no coincide. Discutiremos esto más tarde.</p>
<p><strong>Véase también</strong> Effective Scala que tiene opiniones sobre <a href="http://twitter.github.com/effectivescala/#Functional programming-Pattern matching"> cuándo utilizar coincidencia de patrones </a> y <a href="http://twitter.github.com/effectivescala/#Formatting-Pattern matching">  dar formato a  la coincidencia de patrones</a>. Un recorrido por el Scala describe  también la <a href="http://www.scala-lang.org/node/120"> coincidencia de patrones </a>.</p>
<h3>Coincidencia en el tipo</h3>
<p>Puede usar <code>match</code> para manejar los valores de los diferentes tipos de manera diferente.</p>
<pre>
def bigger(o: Any): Any = {
  o match {
    case i: Int if i &lt; 0 =&gt; i - 1
    case i: Int =&gt; i + 1
    case d: Double if d &lt; 0.0 =&gt; d - 0.1
    case d: Double =&gt; d + 0.1
    case text: String =&gt; text + "s"
  }
}
</pre>
<h3>Coincidencia de miembros de la clase</h3>
<p>Recuerde nuestra calculadora de antes. Vamos a clasificarla según el tipo.<br />
Aquí está primero la manera dificil.</p>
<pre>
def calcType(calc: Calculator) = calc match {
  case _ if calc.brand == "hp" &amp;&amp; calc.model == "20B" =&gt; "financial"
  case _ if calc.brand == "hp" &amp;&amp; calc.model == "48G" =&gt; "scientific"
  case _ if calc.brand == "hp" &amp;&amp; calc.model == "30B" =&gt; "business"
  case _ =&gt; "unknown"
}
</pre>
<p>Wow, eso es dificil. Afortunadamente Scala ofrece algunas herramientas agradables específicamente para esto.</p>
<h2 id="caseclass">Las clases caso (Case Classes)</h2>
<p>Las clases caso se utilizan para almacenar y combinar convenientemente sobre el contenido de una clase. Usted puede construir esto sin usar new.</p>
<pre>
scala&gt; case class Calculator(brand: String, model: String)
defined class Calculator

scala&gt; val hp20b = Calculator("hp", "20b")
hp20b: Calculator = Calculator(hp,20b)

</pre>
<p>Las clases caso tienen automáticamente la igualdad y métodos toString basado en los argumentos del constructor.</p>
<pre>
scala&gt; val hp20b = Calculator("hp", "20b")
hp20b: Calculator = Calculator(hp,20b)

scala&gt; val hp20B = Calculator("hp", "20b")
hp20B: Calculator = Calculator(hp,20b)

scala&gt; hp20b == hp20B
res6: Boolean = true
</pre>
<p>Las clases caso pueden tener métodos al igual que las clases normales.</p>
<h4>Las clase caso con coincidencia de patrones</h4>
<p>Las clases caso se han diseñado para ser utilizadas con la coincidencia de patrones. Vamos a simplificar nuestro ejemplo clasificador de calculadoras de antes.</p>
<pre>
val hp20b = Calculator("hp", "20B")
val hp30b = Calculator("hp", "30B")

def calcType(calc: Calculator) = calc match {
  case Calculator("hp", "20B") =&gt; "financial"
  case Calculator("hp", "48G") =&gt; "scientific"
  case Calculator("hp", "30B") =&gt; "business"
  case Calculator(ourBrand, ourModel) =&gt; "Calculator: %s %s is of unknown type".format(ourBrand, ourModel)
}
</pre>
<p>Otra alternativa para el último match puede ser:</p>
<pre>
  case Calculator(_, _) =&gt; "Calculator of unknown type"
</pre>
O simplemente no podría especificar que se trata de una calculadora en absoluto.

<pre>
  case _ =&gt; "Calculator of unknown type"
</pre>
O podríamos volver a unir el valor emparejado con otro nombre

<pre>
  case c@Calculator(_, _) =&gt; "Calculator: %s of unknown type".format(c)
</pre>
<h2 id="exception">Excepciones</h2>
<p>Las excepciones están disponibles en Scala a través de la sintaxis try-catch-finally que utiliza la coincidencia de patrones.</p>
<pre>
try {
  remoteCalculatorService.add(1, 2)
} catch {
  case e: ServerIsDownException =&gt; log.error(e, "the remote calculator service is unavailable. should have kept your trusty HP.")
} finally {
  remoteCalculatorService.close()
}
</pre>
<p>Los <code>try</code> también están orientados a expresiones.</p>
<pre>
val result: Int = try {
  remoteCalculatorService.add(1, 2)
} catch {
  case e: ServerIsDownException =&gt; {
    log.error(e, "the remote calculator service is unavailable. should have kept your trusty HP.")
    0
  }
} finally {
  remoteCalculatorService.close()
}
</pre>
<p>Esto no es un ejemplo de estilo de programación excelente, es solo un ejemplo de try-catch-finally que resulta en expresiones como casi todo lo demás en la Scala.</p>
<p>Finally será llamado después de que una excepción ha sido manejada y no es parte de la expresión.</p>