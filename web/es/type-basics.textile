---
prev: pattern-matching-and-functional-composition.textile
next: advanced-types.textile
title: Type & polymorphism basics
layout: post
---

<h1>Tipo y polimorfismo básico</h1>
 
<p>Esta lección cubre:</p>


<ul>
	<li><a href="#background">¿Cuáles son los tipos estáticos? </a></li>
	<li><a href="#scala">Tipos en Scala</a></li>
	<li><a href="#parametricpoly">El polimorfismo paramétrico</a></li>
	<li><a href="#inference">La inferencia de tipos: Hindley-Milner vs. inferencia de tipos locales </a></li>
	<li><a href="#Variación">Variación</a></li>
	<li><a href="#bounds">Límites</a></li>
	<li><a href="#quantification">Cuantificación</a></li>
</ul>

<h2 id="background">¿Cuáles son los tipos estáticos? ¿Por qué son útiles?</h2>


De acuerdo a Pierce: “Es un tipo de sistema con un método sintáctico para comprobar automáticamente la ausencia de ciertos comportamientos erróneos mediante la clasificación de las frases del programa de acuerdo a los tipos de valores que computan"

Los tipos te permiten denotar las funciones de un dominio y codominio. Por ejemplo, de las matemáticas, que estamos acostumbrando a ver: 

<pre>
f: R -> N
</pre>

Estos nos dice que la función “f” mapa a partir del conjunto de los números reales a los valores del conjunto de los números naturales. 

En los abstracto, esto es exactamente lo que los tipos de concreto son. Sistemas de tipo que nos dan algunas formas más poderosas para expresas estos conjuntos. 

Dadas estas anotaciones, el compilador no puede estéticamente (En tiempo de compilación) verificar que el programa este correcto. Es decir, el compilador fallará si los valores (en tiempo de ejecución) no cumplen las restricciones impuestas por el programa. 

En términos generales, la typechecker sólo puede garantizar que los programas erróneos no sean compilados. No puede garantizar que todos los programas correctos sean compilados. 

Con el aumento de las expresividad en los sistemas de tipo, podemos producir código más fiable una que nos permite probar invariantes sobre nuestro programa antes de que incluso corra el programa (Por supuesto, en los bugs de los tipos de modelos). La academia esta empujando los limites de la expresividad. Incluyendo los tipos de valor dependiente!

Toma en cuenta que toda la información de tipo se retira en el tiempo de compilación. Ya que no es necesaria. Eso se le llama eliminación,

<h2 id="scala">Tipos en Scala </h2>

El poderoso sistema de Scala permite una expresión rica. Algunos de sus características principales son: 

* *Polimorfismo parametrico* Más o menos programación genérica.
* *Tipos de inferencias (Local)* Más o menos porqué existia la necesidad de definir algo <code>val i: Int = 12: Int</code>
* *Calificación existencial* más o menos, define algo _por un_tipo indefinido
* *Vistas* aprenderemos eso la siguiente semana; más o menos son “moldeados” de los valores de un Tipo a otro
 

<h2 id="parametricpoly"> El polimorfismo paramétrico</h2>

El polimorfismo se utiliza para escribir código genérico (para valores de diferentes tipos)  sin comprometer la riqueza de los tipos estáticos.

Por ejemplo, sin el polimorfismo paramétrico, una estructura de lista de datos genérica sería representada en este aspecto (y de hecho se representa en este aspecto en Java antes de los genéricos): 

<pre>
scala> 2 :: 1 :: "bar" :: "foo" :: Nil
res5: List[Any] = List(2, 1, bar, foo)
</pre>

Ahora no podemos recuperar cualquier información de los miembros individuales: 

<pre>
scala> res5.head
res6: Any = 2
</pre>

Y así nuestra aplicación se volvería en una serie de casts (“asinstanceOf[]” y careceríamos de seguridad (ya que estos tipos son todos dinámicos) 

El polimorfismo se logra a través de la especificación de las variables de tipo. 

<pre>
scala> def drop1[A](l: List[A]) = l.tail
drop1: [A](l: List[A])List[A]

scala> drop1(List(1,2,3))
res1: List[Int] = List(2, 3)
</pre>

<h4>Scala tiene rank-1 polimorfismo </h4>

A grandes rasgos, esto significa que hay algunos conceptos de tipo que te gustaría expresar en Scala que son "demasiado genérico" para el compilador de entender. Supongamos que tenemos una función:

<pre>
def toList[A](a: A) = List(a)
</pre>

por lo cual te gustaría usar de manera genérica: 

<pre>
def foo[A, B](f: A => List[A], b: B) = f(b)
</pre>

Esto no se compila, porque todas las variables de tipo deben ser fijados en el sitio invocación. Incluso si "expusiera" tipo B,

<pre>
def foo[A](f: A => List[A], i: Int) = f(i)
</pre>

…obtines un tipo erroneo. 

<h2 id="inference"> La inferencia de tipos</h2>


Una oposición tradicional de tipos estáticos es que tiene tanta sobrecarga sintáctica. Scala alivia esto proporcionando la inferencia de tipos.

El método clásico para la inferencia de tipos de lenguajes de programación funcional es Hindley-Milner, y fue empleado por primera vez en ML.

Funciona un poco diferente, pero es similar en espíritu: inferir limitaciones, y tratar de unificar a un tipo.Mientras que en OCaml, puede:

El sistema de inferencia de tipos de Scala En Scala, por ejemplo, no se puede hacer lo siguiente: 

<pre>
scala> { x => x }
<console>:7: error: missing parameter type
       { x => x }
</pre>


Mientras que en OCaml, puede:

<pre>
# fun x -> x;;
- : 'a -> 'a = <fun>
</pre>

En scala todo tipo de inferencia es local. Scala considera una expresión a la vez. Por ejemplo:

<pre>
scala> def id[T](x: T) = x
id: [T](x: T)T

scala> val x = id(322)
x: Int = 322

scala> val x = id("hey")
x: java.lang.String = hey

scala> val x = id(Array(1,2,3,4))
x: Array[Int] = Array(1, 2, 3, 4)
</pre>

Tipos ahora se conservan, El compilador de Scala infiere el parámetro de tipo para nosotros. Ten en cuenta también cómo no teníamos que especificar el tipo de retorno de forma explícita.

<h2 id="Variación"> Variación</h2>

El sistema de Scala tiene que tomar en cuenta de las jerarquías de clase junto con el polimorfismo. Jerarquías de clases permiten la expresión de las relaciones de subtipos. Una pregunta fundamenta es, ¿si el Container[T´] es considerado una subclase del Container[T]? Las anotaciones de Variaciones te permiten expresar la siguiente relación entre las clases de jerarquía y los tipos de polimorficos.

<table>
	<tbody><tr>
		<td>                </td>
		<td><strong>Significado</strong>                     </td>
		<td> <strong>Notación Scala</strong></td>
	</tr>
	<tr>
		<td><strong>covariante</strong>     </td>
		<td>C[T’] es una sub - clase de C[T]   </td>
		<td> [+T]</td>
	</tr>
	<tr>
		<td><strong>contravariante</strong> </td>
		<td>C[T] es una sub - clase de C[T’]   </td>
		<td> [-T]</td>
	</tr>
	<tr>
		<td><strong>invariante</strong>     </td>
		<td>C[T] y C[T’] no están relacionados</td>
		<td> [T]</td>
	</tr>
</tbody></table>

La relación subtipo realmente significa: para un determinado tipo T, si T 'es un subtipo, puede ser sustituido?

<pre>
scala> class Covariant[+A]
defined class Covariant

scala> val cv: Covariant[AnyRef] = new Covariant[String]
cv: Covariant[AnyRef] = Covariant@4035acf6

scala> val cv: Covariant[String] = new Covariant[AnyRef]
<console>:6: error: type mismatch;
 found   : Covariant[AnyRef]
 required: Covariant[String]
       val cv: Covariant[String] = new Covariant[AnyRef]
                                   ^
</pre>

<pre>
scala> class Contravariant[-A]
defined class Contravariant

scala> val cv: Contravariant[String] = new Contravariant[AnyRef]
cv: Contravariant[AnyRef] = Contravariant@49fa7ba

scala> val fail: Contravariant[AnyRef] = new Contravariant[String]
<console>:6: error: type mismatch;
 found   : Contravariant[String]
 required: Contravariant[AnyRef]
       val fail: Contravariant[AnyRef] = new Contravariant[String]
                                     ^
</pre>


Contravarianza parece extraño. Cuando se utiliza? Algo sorprendente!

<pre>
trait Function1 [-T1, +R] extends AnyRef
</pre>

Si piensas en esto desde el punto de vista de la sustitución, tiene mucho sentido. Primero vamos a definir una jerarquía de clases simple:

<pre>
scala> class Animal { val sound = "rustle" }
defined class Animal

scala> class Bird extends Animal { override val sound = "call" }
defined class Bird

scala> class Chicken extends Bird { override val sound = "cluck" }
defined class Chicken
</pre>

Supongamos que necesitas una función que tome un parámetro de <code>Bird</code>:

<pre>
scala> val getTweet: (Bird => String) = // TODO
</pre>

La biblioteca animal estándar tiene una función que hace lo que quiere, pero se necesita un parámetro <code>Animal</code>. En la mayoría de las situaciones, si usted dice que "necesito un ___, tengo una subclase de ___",  estás bien. Pero los parámetros de la función son contravariante. Si necesita una función que toma un <code>Bird</code> y tiene una función que toma un <code>Chicken</code>, esa función se fijara en un <code>Duck</code>.. Pero una función que toma un <code>Animal</code> está bien:

<pre>
scala> val getTweet: (Bird => String) = ((a: Animal) => a.sound )
getTweet: Bird => String = <function1>
</pre>


Tipo de valor de retorno de una función es covariante. Si tienes una función que regresa a un <code>Bird</code>  pero tienes una función que regresa a Chicken,, eso esta bien.


<pre>
scala> val hatch: (() => Bird) = (() => new Chicken )
hatch: () => Bird = <function0>
</pre>

<h2 id="bounds"> Límites</h2>

Scala permite restringir las variables polimórficas utilizando límites. Estos límites expresan las relaciones de subtipos.

<pre>
scala> def cacophony[T](things: Seq[T]) = things map (_.sound)
<console>:7: error: value sound is not a member of type parameter T
       def cacophony[T](things: Seq[T]) = things map (_.sound)
                                                        ^
scala> def biophony[T <: Animal](things: Seq[T]) = things map (_.sound)
biophony: [T <: Animal](things: Seq[T])Seq[java.lang.String]

scala> biophony(Seq(new Chicken, new Bird))
res5: Seq[java.lang.String] = List(cluck, call)
</pre>

Límites de tipo más bajas también son compatibles; son práctico con la contravarianza y covarianza inteligente. <code>List[+T]</code> es covariante; una lista de las Aves es una lista de los Animales. <code>List </code> define una operación <code>::(elem T)</code> que refleja una nueva <code>List</code>  con <code>elem</code>  fijados. La <code>List</code> nueva tiene los mismos tipos que la original. 

<pre>
scala> val flock = List(new Bird, new Bird)
flock: List[Bird] = List(Bird@7e1ec70e, Bird@169ea8d2)

scala> new Chicken :: flock
res53: List[Bird] = List(Chicken@56fbda05, Bird@7e1ec70e, Bird@169ea8d2)
</pre>

<code>Lista</code> tambien define <code>::[B >: T](x: B)</code> lo cual refleja a <code>List[B]</code>.. Observa que <code>B >: T..</code> Ese tipo especifico <code>B</code> es una clase superior de <code>T</code>. Que nos permite ejecutar la accione correcta cuando buscamos a <code>Animal</code>  en la <code>List[Bird]</code>:

<pre>
scala> new Animal :: flock
res59: List[Animal] = List(Animal@11f8d3a8, Bird@7e1ec70e, Bird@169ea8d2)
</pre>

Observa que el tipo de retorna es <code>List[Animal].</code>

<h2 id="quantification"> Cuantificación
</h2>


A veces no le importa ser capaz de nombrar una variable de tipo, por ejemplo:

<pre>
scala> def count[A](l: List[A]) = l.size
count: [A](List[A])Int
</pre>

En su lugar se puede usar “wildcards":

<pre>
scala> def count(l: List[_]) = l.size
count: (List[_])Int
</pre>

Este es un hack para: 

<pre>
scala> def count(l: List[T forSome { type T }]) = l.size
count: (List[T forSome { type T }])Int
</pre>

Tenga en cuenta que la cuantificación puede ser complicado:

<pre>
scala> def drop1(l: List[_]) = l.tail
drop1: (List[_])List[Any]
</pre>

De repente perdimos información de tipo! Para ver lo que está pasando, puedes revertir la sintaxis pesada:

<pre>
scala> def drop1(l: List[T forSome { type T }]) = l.tail
drop1: (List[T forSome { type T }])List[T forSome { type T }]
</pre>

No podemos decir nada acerca de T porque el tipo no lo permite.

También se puede aplicar límites a la variables de tipo “wildcard":

<pre>
scala> def hashcodes(l: Seq[_ <: AnyRef]) = l map (_.hashCode)
hashcodes: (Seq[_ <: AnyRef])Seq[Int]

scala> hashcodes(Seq(1,2,3))
<console>:7: error: type mismatch;
 found   : Int(1)
 required: AnyRef
Note: primitive types are not implicitly converted to AnyRef.
You can safely force boxing by casting x.asInstanceOf[AnyRef].
       hashcodes(Seq(1,2,3))
                     ^

scala> hashcodes(Seq("one", "two", "three"))
res1: Seq[Int] = List(110182, 115276, 110339486)
</pre>

*Recurso adicional:* <a href="http://www.drmaciver.com/2008/03/existential-types-in-scala/">Existential types in Scala by D. R. MacIver</a>
*See Also* <a href="http://www.drmaciver.com/2008/03/existential-types-in-scala/">Existential types in Scala by D. R. MacIver</a>
